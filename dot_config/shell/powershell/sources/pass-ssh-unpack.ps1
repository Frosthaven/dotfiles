# pass-ssh-unpack: Extract SSH keys from Proton Pass to local files
# See: docs/pass-ssh-unpack.md

function pass-ssh-unpack {
    [CmdletBinding()]
    param(
        [Parameter()]
        [Alias("v")]
        [string[]]$Vault,
        
        [Parameter()]
        [Alias("i")]
        [string[]]$Item,
        
        [Parameter()]
        [Alias("f")]
        [switch]$Full,
        
        [Parameter()]
        [Alias("q")]
        [switch]$Quiet
    )
    
    # Helper function for output
    function Write-Log {
        param([string]$Message)
        if (-not $Quiet) {
            Write-Host $Message
        }
    }
    
    # =========================================================================
    # Dependency checks
    # =========================================================================
    $passCli = Get-Command pass-cli -ErrorAction SilentlyContinue
    if (-not $passCli) {
        Write-Host "(pass-ssh-unpack) pass-cli not found. Install Proton Pass CLI first." -ForegroundColor Red
        return
    }

    $null = pass-cli info 2>&1
    if ($LASTEXITCODE -ne 0) {
        Write-Host "(pass-ssh-unpack) Not logged into Proton Pass. Run 'pass-cli login' first." -ForegroundColor Red
        return
    }

    $sshKeygen = Get-Command ssh-keygen -ErrorAction SilentlyContinue
    if (-not $sshKeygen) {
        Write-Host "(pass-ssh-unpack) ssh-keygen not found. Install OpenSSH first." -ForegroundColor Red
        return
    }

    Write-Log "Extracting SSH keys from Proton Pass..."
    Write-Log ""

    # =========================================================================
    # Setup
    # =========================================================================
    $currentHostname = $env:COMPUTERNAME.ToLower()
    $baseDir = Join-Path $env:USERPROFILE ".ssh\proton-pass"
    
    # Full mode: delete entire folder and start fresh
    if ($Full -and (Test-Path $baseDir)) {
        Write-Log "Full regeneration: clearing $baseDir..."
        Remove-Item -Path $baseDir -Recurse -Force
    }
    
    if (-not (Test-Path $baseDir)) {
        New-Item -ItemType Directory -Path $baseDir -Force | Out-Null
    }

    $configPath = Join-Path $baseDir "config"
    $configHeader = @"
# =============================================================================
# DO NOT EDIT THIS FILE - IT IS AUTO-GENERATED BY pass-ssh-unpack
# =============================================================================
# Any manual changes will be lost on the next run.
#
# To use these keys, add the following to your ~/.ssh/config:
#     Include ~/.ssh/proton-pass/config
#
# To regenerate: pass-ssh-unpack
# To regenerate fully: pass-ssh-unpack -Full
# =============================================================================
"@

    # =========================================================================
    # Load existing config (for incremental updates)
    # =========================================================================
    $existingHosts = @{}
    
    if (-not $Full -and (Test-Path $configPath)) {
        $currentHost = ""
        $currentBlock = ""
        $inBlock = $false
        
        foreach ($line in (Get-Content $configPath)) {
            # Skip header comments
            if ($line -match "DO NOT EDIT" -or $line -match "=====" -or $line -match "Include" -or $line -match "regenerate" -or $line -match "To use") {
                continue
            }
            
            if ($line -match "^Host (.+)$") {
                # Save previous block if exists
                if ($currentHost) {
                    $existingHosts[$currentHost] = $currentBlock
                }
                $currentHost = $Matches[1]
                $currentBlock = $line
                $inBlock = $true
            } elseif ($inBlock -and $line) {
                $currentBlock = "$currentBlock`n$line"
            }
        }
        
        # Save last block
        if ($currentHost) {
            $existingHosts[$currentHost] = $currentBlock
        }
    }

    # =========================================================================
    # Get vaults to process
    # =========================================================================
    $vaultsJson = pass-cli vault list --output json | ConvertFrom-Json
    $allVaults = $vaultsJson.vaults | ForEach-Object { $_.name }
    
    $vaultsToProcess = @()
    if (-not $Vault -or $Vault.Count -eq 0) {
        $vaultsToProcess = $allVaults
    } else {
        # Filter vaults with wildcard support
        foreach ($pattern in $Vault) {
            $matched = $false
            foreach ($v in $allVaults) {
                if ($v -like $pattern) {
                    if ($vaultsToProcess -notcontains $v) {
                        $vaultsToProcess += $v
                    }
                    $matched = $true
                }
            }
            if (-not $matched) {
                Write-Log "Warning: No vaults matching '$pattern' found"
            }
        }
    }

    # =========================================================================
    # Helper: Check if title matches any pattern
    # =========================================================================
    function Test-PatternMatch {
        param([string]$Title, [string[]]$Patterns)
        
        if (-not $Patterns -or $Patterns.Count -eq 0) {
            return $true
        }
        
        foreach ($pattern in $Patterns) {
            if ($Title -like $pattern) {
                return $true
            }
        }
        return $false
    }

    # =========================================================================
    # Process vaults and extract keys
    # =========================================================================
    $newHosts = @{}
    $processedKeys = @()

    foreach ($vault in $vaultsToProcess) {
        if ([string]::IsNullOrEmpty($vault)) { continue }

        Write-Log "[$vault]"

        $keysJson = pass-cli item list $vault --filter-type ssh-key --output json 2>$null
        if ([string]::IsNullOrEmpty($keysJson)) {
            Write-Log "  (no SSH keys)"
            Write-Log ""
            continue
        }

        try {
            $keys = $keysJson | ConvertFrom-Json
        } catch {
            Write-Log "  (no SSH keys)"
            Write-Log ""
            continue
        }

        if (-not $keys.items -or $keys.items.Count -eq 0) {
            Write-Log "  (no SSH keys)"
            Write-Log ""
            continue
        }

        $vaultDir = Join-Path $baseDir $vault
        if (-not (Test-Path $vaultDir)) {
            New-Item -ItemType Directory -Path $vaultDir -Force | Out-Null
        }

        foreach ($item in $keys.items) {
            $title = $item.content.title
            
            # Check if title matches patterns
            if (-not (Test-PatternMatch -Title $title -Patterns $Item)) {
                continue
            }
            
            # Check machine-specific suffix
            if ($title -match '/') {
                $titleSuffix = ($title -split '/')[-1].ToLower()
                if ($titleSuffix -ne $currentHostname) {
                    Write-Log "  Skipping: $title (not for this machine)"
                    continue
                }
            }
            
            Write-Log "  Processing: $title"

            $privateKey = $item.content.content.SshKey.private_key
            $existingPubkey = $item.content.content.SshKey.public_key

            # Get fields from extra_fields
            $hostField = $null
            $usernameField = $null
            $aliasesField = $null
            foreach ($field in $item.content.extra_fields) {
                if ($field.name -eq "Host" -and $field.content.Text) {
                    $hostField = $field.content.Text
                }
                if ($field.name -eq "Username" -and $field.content.Text) {
                    $usernameField = $field.content.Text
                }
                if ($field.name -eq "Aliases" -and $field.content.Text) {
                    $aliasesField = $field.content.Text
                }
            }

            if ([string]::IsNullOrEmpty($hostField)) {
                Write-Log "    -> skipped (no Host field)"
                continue
            }

            # Sanitize title for filename
            $safeTitle = $title -replace '/', '-' -replace ' ', '_'

            $privkeyPath = Join-Path $vaultDir $safeTitle
            $pubkeyPath = Join-Path $vaultDir "$safeTitle.pub"

            # Check if there's a private key
            $hasKey = $false
            $identityPath = ""

            if (-not [string]::IsNullOrEmpty($privateKey)) {
                # Write private key
                "$privateKey`n" | Set-Content -Path $privkeyPath -NoNewline
                
                # Set file permissions (Windows equivalent of chmod 600)
                $acl = Get-Acl $privkeyPath
                $acl.SetAccessRuleProtection($true, $false)
                $rule = New-Object System.Security.AccessControl.FileSystemAccessRule(
                    [System.Security.Principal.WindowsIdentity]::GetCurrent().Name,
                    "FullControl",
                    "Allow"
                )
                $acl.SetAccessRule($rule)
                Set-Acl -Path $privkeyPath -AclObject $acl
                
                # Track this key file
                $processedKeys += $privkeyPath

                # Generate public key
                $generatedPubkey = ssh-keygen -y -f $privkeyPath 2>$null
                if ($LASTEXITCODE -eq 0 -and $generatedPubkey) {
                    $generatedPubkey | Set-Content -Path $pubkeyPath -NoNewline
                    $hasKey = $true
                    $identityPath = "%d/.ssh/proton-pass/$vault/$safeTitle"

                    # Save public key back to Proton Pass if empty
                    if ([string]::IsNullOrEmpty($existingPubkey)) {
                        $null = pass-cli item update --vault-name $vault --item-title $title --field "public_key=$generatedPubkey" 2>&1
                        if ($LASTEXITCODE -eq 0) {
                            Write-Log "    -> $safeTitle (saved pubkey to Proton Pass)"
                        } else {
                            Write-Log "    -> $safeTitle (failed to save pubkey to Proton Pass)"
                        }
                    } else {
                        Write-Log "    -> $safeTitle"
                    }
                } else {
                    Write-Log "    -> $safeTitle (failed to generate public key)"
                    Remove-Item $privkeyPath -Force -ErrorAction SilentlyContinue
                }
            } else {
                Write-Log "    -> $safeTitle (no key, password auth)"
            }

            # Build config entries (with or without key)
            $configBlock = "Host $hostField"
            if ($hasKey) {
                $configBlock = "$configBlock`n    IdentityFile `"$identityPath`"`n    IdentitiesOnly yes"
            }
            if (-not [string]::IsNullOrEmpty($usernameField)) {
                $configBlock = "$configBlock`n    User $usernameField"
            }
            $newHosts[$hostField] = $configBlock
            
            # Alias entries
            $aliasesList = @()
            if (-not [string]::IsNullOrEmpty($aliasesField)) {
                $aliasesList = $aliasesField -split ',' | ForEach-Object { $_.Trim() } | Where-Object { $_ }
            } else {
                $aliasesList = @($title)
            }
            
            foreach ($aliasEntry in $aliasesList) {
                if ([string]::IsNullOrEmpty($aliasEntry)) { continue }
                if ($aliasEntry -eq $hostField) { continue }
                
                $aliasBlock = "# Alias of $hostField`nHost $aliasEntry"
                if ($hasKey) {
                    $aliasBlock = "$aliasBlock`n    IdentityFile `"$identityPath`"`n    IdentitiesOnly yes"
                }
                if (-not [string]::IsNullOrEmpty($usernameField)) {
                    $aliasBlock = "$aliasBlock`n    User $usernameField"
                }
                $newHosts[$aliasEntry] = $aliasBlock
            }
        }

        Write-Log ""
    }

    # =========================================================================
    # Merge configs and auto-prune
    # =========================================================================
    Write-Log "Generating SSH config..."
    
    # Merge: new hosts override existing, keep existing if not touched
    $finalHosts = @{}
    
    # Start with existing hosts (if incremental mode)
    if (-not $Full) {
        foreach ($key in $existingHosts.Keys) {
            $finalHosts[$key] = $existingHosts[$key]
        }
    }
    
    # Override/add new hosts
    foreach ($key in $newHosts.Keys) {
        $finalHosts[$key] = $newHosts[$key]
    }
    
    # Auto-prune: remove entries whose key files don't exist
    # (only prune entries that have an IdentityFile - password-only entries are kept)
    $hostsToRemove = @()
    foreach ($host in $finalHosts.Keys) {
        $block = $finalHosts[$host]
        if ($block -match 'IdentityFile "([^"]*)"') {
            $idFile = $Matches[1] -replace '%d', $env:USERPROFILE
            if ($idFile -and -not (Test-Path $idFile)) {
                $hostsToRemove += $host
            }
        }
    }
    
    $prunedCount = $hostsToRemove.Count
    foreach ($host in $hostsToRemove) {
        $finalHosts.Remove($host)
    }

    # =========================================================================
    # Write final config
    # =========================================================================
    $configHeader | Set-Content -Path $configPath
    
    # Sort hosts for consistent output
    $sortedHosts = $finalHosts.Keys | Sort-Object
    
    foreach ($host in $sortedHosts) {
        Add-Content -Path $configPath -Value ""
        Add-Content -Path $configPath -Value $finalHosts[$host]
    }

    # =========================================================================
    # Summary
    # =========================================================================
    $totalHosts = $sortedHosts.Count
    $totalAliases = ($finalHosts.Values | Where-Object { $_ -match "# Alias of" }).Count
    $primaryHosts = $totalHosts - $totalAliases

    Write-Log ""
    Write-Log "Done! Generated config has $primaryHosts hosts and $totalAliases aliases."
    if ($prunedCount -gt 0) {
        Write-Log "Pruned $prunedCount orphaned entries."
    }
    Write-Log "SSH config written to: $configPath"
}
