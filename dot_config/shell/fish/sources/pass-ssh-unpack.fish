# pass-ssh-unpack: Extract SSH keys from Proton Pass to local files
# See: docs/pass-ssh-unpack.md

function pass-ssh-unpack
    # =========================================================================
    # Argument parsing
    # =========================================================================
    set -l vault_names
    set -l item_patterns
    set -l full_mode false
    set -l quiet_mode false
    
    set -l i 1
    while test $i -le (count $argv)
        switch $argv[$i]
            case -v --vault
                set i (math $i + 1)
                set -a vault_names $argv[$i]
            case -i --item
                set i (math $i + 1)
                set -a item_patterns $argv[$i]
            case -f --full
                set full_mode true
            case -q --quiet
                set quiet_mode true
            case -h --help
                echo "Usage: pass-ssh-unpack [OPTIONS]"
                echo ""
                echo "Extract SSH keys from Proton Pass to local files and generate SSH config."
                echo ""
                echo "Options:"
                echo "  -v, --vault <PATTERN>      Vault(s) to process, supports * and ? wildcards"
                echo "  -i, --item <PATTERN>       Item title pattern(s) to unpack (repeatable)"
                echo "                             Supports * and ? wildcards"
                echo "  -f, --full                 Full regeneration (clear config first)"
                echo "  -q, --quiet                Suppress output"
                echo "  -h, --help                 Show this help message"
                echo ""
                echo "Examples:"
                echo "  pass-ssh-unpack                            # All vaults, all keys"
                echo "  pass-ssh-unpack -v Personal                # All keys from Personal vault"
                echo "  pass-ssh-unpack -v 'Dragon*'               # Vaults matching pattern"
                echo "  pass-ssh-unpack -i 'github/*'              # Keys matching pattern"
                echo "  pass-ssh-unpack -v Personal -i 'github/*'  # Combined filters"
                echo "  pass-ssh-unpack --full                     # Full regeneration"
                return 0
            case '*'
                echo "Unknown option: $argv[$i]"
                echo "Use --help for usage information."
                return 1
        end
        set i (math $i + 1)
    end
    
    # Helper function for output
    function _log
        if test "$quiet_mode" != "true"
            echo $argv
        end
    end
    
    # =========================================================================
    # Dependency checks
    # =========================================================================
    if not command -q pass-cli
        echo "(pass-ssh-unpack) pass-cli not found. Install Proton Pass CLI first."
        return 1
    end
    
    if not pass-cli info &>/dev/null
        echo "(pass-ssh-unpack) Not logged into Proton Pass. Run 'pass-cli login' first."
        return 1
    end
    
    if not command -q ssh-keygen
        echo "(pass-ssh-unpack) ssh-keygen not found. Install OpenSSH first."
        return 1
    end
    
    if not command -q jq
        echo "(pass-ssh-unpack) jq not found. Install jq first."
        return 1
    end
    
    _log "Extracting SSH keys from Proton Pass..."
    _log ""
    
    # =========================================================================
    # Setup
    # =========================================================================
    set -l current_hostname (hostname | tr '[:upper:]' '[:lower:]')
    set -l base_dir "$HOME/.ssh/proton-pass"
    mkdir -p "$base_dir"
    
    set -l config_path "$base_dir/config"
    set -l config_header "# =============================================================================
# DO NOT EDIT THIS FILE - IT IS AUTO-GENERATED BY pass-ssh-unpack
# =============================================================================
# Any manual changes will be lost on the next run.
#
# To use these keys, add the following to your ~/.ssh/config:
#     Include ~/.ssh/proton-pass/config
#
# To regenerate: pass-ssh-unpack
# To regenerate fully: pass-ssh-unpack --full
# ============================================================================="

    # =========================================================================
    # Load existing config (for incremental updates)
    # =========================================================================
    # We'll store existing hosts in temp files: one file per host
    set -l existing_hosts_dir "$base_dir/.existing_hosts_tmp"
    rm -rf "$existing_hosts_dir"
    mkdir -p "$existing_hosts_dir"
    
    if test "$full_mode" != "true"; and test -f "$config_path"
        set -l current_host ""
        set -l current_block ""
        set -l in_block false
        
        while read -l line; or test -n "$line"
            # Skip header comments
            if string match -q "*DO NOT EDIT*" -- "$line"; or string match -q "*=====*" -- "$line"; or string match -q "*Include*" -- "$line"; or string match -q "*regenerate*" -- "$line"; or string match -q "*To use*" -- "$line"
                continue
            end
            
            if string match -qr "^Host (.+)\$" -- "$line"
                # Save previous block if exists
                if test -n "$current_host"
                    set -l safe_host (string replace -a '/' '_' -- "$current_host" | string replace -a ' ' '_')
                    echo "$current_block" > "$existing_hosts_dir/$safe_host"
                end
                set current_host (string replace "Host " "" -- "$line")
                set current_block "$line"
                set in_block true
            else if test "$in_block" = "true"; and test -n "$line"
                set current_block "$current_block
$line"
            end
        end < "$config_path"
        
        # Save last block
        if test -n "$current_host"
            set -l safe_host (string replace -a '/' '_' -- "$current_host" | string replace -a ' ' '_')
            echo "$current_block" > "$existing_hosts_dir/$safe_host"
        end
    end
    
    # =========================================================================
    # Get vaults to process
    # =========================================================================
    set -l all_vaults (pass-cli vault list --output json | jq -r '.vaults[].name')
    set -l vaults_to_process
    
    if test (count $vault_names) -eq 0
        # No vault filter - process all
        for v in $all_vaults
            test -n "$v"; and set -a vaults_to_process "$v"
        end
    else
        # Filter to specified vaults (with wildcard support)
        for pattern in $vault_names
            set -l matched false
            for v in $all_vaults
                test -z "$v"; and continue
                # Use fish glob matching
                if string match -q -- "$pattern" "$v"
                    set -a vaults_to_process "$v"
                    set matched true
                end
            end
            if test "$matched" = "false"
                _log "Warning: No vaults matching '$pattern' found"
            end
        end
    end
    
    # =========================================================================
    # Helper: Check if title matches any pattern
    # =========================================================================
    function _matches_pattern --inherit-variable item_patterns
        set -l title $argv[1]
        
        # If no patterns specified, match all
        if test (count $item_patterns) -eq 0
            return 0
        end
        
        for pattern in $item_patterns
            # Use fish glob matching with string match -w (wildcard)
            if string match -q -- "$pattern" "$title"
                return 0
            end
        end
        return 1
    end
    
    # =========================================================================
    # Process vaults and extract keys
    # =========================================================================
    set -l new_hosts_dir "$base_dir/.new_hosts_tmp"
    rm -rf "$new_hosts_dir"
    mkdir -p "$new_hosts_dir"
    
    set -l processed_keys_file "$base_dir/.processed_keys_tmp"
    rm -f "$processed_keys_file"
    
    for vault in $vaults_to_process
        test -z "$vault"; and continue
        
        _log "[$vault]"
        
        set -l keys_json (pass-cli item list "$vault" --filter-type ssh-key --output json 2>/dev/null)
        
        if test -z "$keys_json"; or test "$keys_json" = "null"
            _log "  (no SSH keys)"
            _log ""
            continue
        end
        
        set -l item_count (echo "$keys_json" | jq '.items | length')
        
        if test "$item_count" = "0"; or test "$item_count" = "null"
            _log "  (no SSH keys)"
            _log ""
            continue
        end
        
        set -l vault_dir "$base_dir/$vault"
        mkdir -p "$vault_dir"
        
        for item in (echo "$keys_json" | jq -c '.items[]')
            set -l title (echo "$item" | jq -r '.content.title')
            
            # Check if title matches patterns
            if not _matches_pattern "$title"
                continue
            end
            
            # Check machine-specific suffix
            if string match -q "*/*" -- "$title"
                set -l title_suffix (echo "$title" | sed 's|.*/||' | tr '[:upper:]' '[:lower:]')
                if test "$title_suffix" != "$current_hostname"
                    _log "  Skipping: $title (not for this machine)"
                    continue
                end
            end
            
            _log "  Processing: $title"
            
            set -l private_key (echo "$item" | jq -r '.content.content.SshKey.private_key')
            set -l existing_pubkey (echo "$item" | jq -r '.content.content.SshKey.public_key // ""')
            set -l host_field (echo "$item" | jq -r '.content.extra_fields[] | select(.name == "Host") | .content.Text' | head -1)
            set -l username_field (echo "$item" | jq -r '.content.extra_fields[] | select(.name == "Username") | .content.Text' | head -1)
            set -l aliases_field (echo "$item" | jq -r '.content.extra_fields[] | select(.name == "Aliases") | .content.Text' | head -1)
            
            if test -z "$host_field"; or test "$host_field" = "null"
                _log "    -> skipped (no Host field)"
                continue
            end
            
            set -l safe_title (echo "$title" | tr '/' '-' | tr ' ' '_')
            set -l privkey_path "$vault_dir/$safe_title"
            set -l pubkey_path "$vault_dir/$safe_title.pub"
            
            # Check if there's a private key
            set -l has_key false
            set -l identity_path ""
            
            if test -n "$private_key"; and test "$private_key" != "null"; and test "$private_key" != ""
                # Write private key
                echo "$private_key" > "$privkey_path"
                chmod 600 "$privkey_path"
                
                # Track this key file
                echo "$privkey_path" >> "$processed_keys_file"
                
                # Generate public key
                set -l generated_pubkey (ssh-keygen -y -f "$privkey_path" 2>/dev/null)
                
                if test -n "$generated_pubkey"
                    echo "$generated_pubkey" > "$pubkey_path"
                    set has_key true
                    set identity_path "%d/.ssh/proton-pass/$vault/$safe_title"
                    
                    # Save public key back to Proton Pass if empty
                    if test -z "$existing_pubkey"
                        if pass-cli item update --vault-name "$vault" --item-title "$title" --field "public_key=$generated_pubkey" &>/dev/null
                            _log "    -> $safe_title (saved pubkey to Proton Pass)"
                        else
                            _log "    -> $safe_title (failed to save pubkey to Proton Pass)"
                        end
                    else
                        _log "    -> $safe_title"
                    end
                else
                    _log "    -> $safe_title (failed to generate public key)"
                    rm -f "$privkey_path"
                end
            else
                _log "    -> $safe_title (no key, password auth)"
            end
            
            # Build config entries (with or without key)
            set -l config_block "Host $host_field"
            if test "$has_key" = "true"
                set config_block "$config_block
    IdentityFile \"$identity_path\"
    IdentitiesOnly yes"
            end
            if test -n "$username_field"; and test "$username_field" != "null"
                set config_block "$config_block
    User $username_field"
            end
            
            set -l safe_host (string replace -a '/' '_' -- "$host_field" | string replace -a ' ' '_')
            echo "$config_block" > "$new_hosts_dir/$safe_host"
            
            # Alias entries
            set -l aliases_list
            if test -n "$aliases_field"; and test "$aliases_field" != "null"
                set aliases_list (string split "," -- "$aliases_field" | string trim)
            else
                set aliases_list "$title"
            end
            
            for alias_entry in $aliases_list
                set alias_entry (string trim -- "$alias_entry")
                test -z "$alias_entry"; and continue
                test "$alias_entry" = "$host_field"; and continue
                
                set -l alias_block "# Alias of $host_field
Host $alias_entry"
                if test "$has_key" = "true"
                    set alias_block "$alias_block
    IdentityFile \"$identity_path\"
    IdentitiesOnly yes"
                end
                if test -n "$username_field"; and test "$username_field" != "null"
                    set alias_block "$alias_block
    User $username_field"
                end
                
                set -l safe_alias (string replace -a '/' '_' -- "$alias_entry" | string replace -a ' ' '_')
                echo "$alias_block" > "$new_hosts_dir/$safe_alias"
            end
        end
        
        _log ""
    end
    
    # =========================================================================
    # Merge configs and auto-prune
    # =========================================================================
    _log "Generating SSH config..."
    
    # Merge: new hosts override existing, keep existing if not touched
    set -l final_hosts_dir "$base_dir/.final_hosts_tmp"
    rm -rf "$final_hosts_dir"
    mkdir -p "$final_hosts_dir"
    
    # Start with existing hosts (if incremental mode)
    if test "$full_mode" != "true"
        for f in $existing_hosts_dir/*
            test -f "$f"; and cp "$f" "$final_hosts_dir/"
        end
    end
    
    # Override/add new hosts
    for f in $new_hosts_dir/*
        test -f "$f"; and cp "$f" "$final_hosts_dir/"
    end
    
    # Auto-prune: remove entries whose key files don't exist
    # (only prune entries that have an IdentityFile - password-only entries are kept)
    set -l pruned_count 0
    for f in $final_hosts_dir/*
        test -f "$f"; or continue
        
        set -l block (cat "$f")
        set -l id_file (echo "$block" | grep -o 'IdentityFile "[^"]*"' | sed 's/IdentityFile "//;s/"$//' | sed "s|%d|$HOME|")
        
        if test -n "$id_file"; and not test -f "$id_file"
            rm -f "$f"
            set pruned_count (math $pruned_count + 1)
        end
    end
    
    # Clean up temp files
    rm -f "$processed_keys_file"
    rm -rf "$existing_hosts_dir" "$new_hosts_dir"
    
    # =========================================================================
    # Write final config
    # =========================================================================
    echo "$config_header" > "$config_path"
    
    # Count totals
    set -l total_hosts 0
    set -l total_aliases 0
    
    # Sort hosts for consistent output
    for f in (ls "$final_hosts_dir" 2>/dev/null | sort)
        test -f "$final_hosts_dir/$f"; or continue
        
        set -l block (cat "$final_hosts_dir/$f")
        echo "" >> "$config_path"
        echo "$block" >> "$config_path"
        
        set total_hosts (math $total_hosts + 1)
        if string match -q "*# Alias of*" -- "$block"
            set total_aliases (math $total_aliases + 1)
        end
    end
    
    rm -rf "$final_hosts_dir"
    
    # =========================================================================
    # Summary
    # =========================================================================
    set -l primary_hosts (math $total_hosts - $total_aliases)
    
    _log ""
    _log "Done! Generated config has $primary_hosts hosts and $total_aliases aliases."
    if test $pruned_count -gt 0
        _log "Pruned $pruned_count orphaned entries."
    end
    _log "SSH config written to: $config_path"
    
    # Clean up helper function
    functions -e _log
    functions -e _matches_pattern
end
